; Mapip family.  -*- Scheme -*-
; Copyright 2000, 2001, 2011 Free Software Foundation, Inc.
; Contributed by Johan Rydberg, jrydberg@opencores.org
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.

(include "simplify.inc")

; Mapip is the virtual processor used by MoSync,
; a cross-platform SDK for mobile devices.
; It is a simple 32-bit architecture with about 50 opcodes.
; In the future we will add isa mapip32f,
; which will have 32 64-bit floating-point registers, and opcodes to match.

(define-arch
	(name mapip)
	(comment "Mapip")
	(insn-lsb0? #t)
	(machs mapip)
	(isas mapip32)
)

; IDOC attribute for instruction documentation.

(define-attr
	(for insn)
	(type enum)
	(name IDOC)
	(comment "insn kind for documentation")
	(attrs META)
	(values
		(MEM - () "Memory")
		(ALU - () "ALU")
		(FPU - () "FPU")
		(BR - () "Branch")
		(MISC - () "Miscellaneous")
	)
)

; Enum for exception vectors.
;(define-enum
;	(name e-exception)
;	(comment "exception vectors")
;	(attrs)
;	(prefix E_)
;	(values (("RESET") ("BUSERR" -) ("DPF" -) ("IPF" -) ("EXTINT" -) ("ALIGN" -)
;		("ILLEGAL" -) ("PEINT" -) ("DTLBMISS" -) ("ITLBMISS" -) ("RRANGE" -)
;		("SYSCALL" -) ("BREAK" -) ("RESERVED" -)))
;)


; Instruction set parameters.

(define-isa
	; Name of the ISA.
	(name mapip32)

	; Base instruction length, in bits.
	(base-insn-bitsize 8)
)

; CPU family definitions.

(define-cpu
	; CPU names must be distinct from the architecture name and machine names.
	; The "b" suffix stands for "base" and is the convention.
	; The "f" suffix stands for "family" and is the convention.
	(name mapipbf)
	(comment "Mapip base family")
	(endian little)
	(word-bitsize 32)
)

; Generic machine
(define-mach
	(name mapip)
	(comment "Generic Mapip cpu")
	(cpu mapipbf)
	(bfd-name "mapip")
)


; Model descriptions

; Generic OpenRISC model
(define-model
	(name mapip-1)
	(comment "Mapip generic model")
	(attrs)
	(mach mapip)

	; Nothing special about this.
	(unit u-exec "Execution Unit" () 1 1 () () () ())
)

; Hardware

(dnh h-pc "program counter" (PC PROFILE) (pc) () () ())

;  GPRs

(define-keyword
	(name gpr-names)
	(print-name h-gpr)
	(prefix "")
	(values
		(zero 0) (sp 1) (rt 2) (fr 3)
		(d0 4) (d1 5) (d2 6) (d3 7) (d4 8) (d5 9) (d6 10) (d7 11)
		(i0 12) (i1 13) (i2 14) (i3 15)
		(r0 16) (r1 17) (r2 18) (r3 19) (r4 20) (r5 21) (r6 22) (r7 23)
		(r8 24) (r9 25) (r10 26) (r11 27) (r12 28) (r13 29) (r14 30) (r15 31)
	)
)

(define-hardware
	(name h-gpr)
	(comment "general purpose registers")
	(attrs)
	(type register WI (32))
	(indices extern-keyword gpr-names)
)

(define-attr
  (for operand)
  (type boolean)
  (name HASH-PREFIX)
  (comment "immediates have a required '#' prefix")
)

; Instruction fields
(define-ifield
	(name f-op)
	(comment "f-opcode")
	(attrs)
	(word-offset 0)
	(word-length 8)
	(start 0)
	(length 8)
	(mode UINT)
)

(define-ifield
	(name f-r1)
	(comment "f-reg1")
	(attrs)
	(word-offset 0)
	(word-length 8)
	(start 0)
	(length 8)
	(mode UINT)
)

(define-ifield
	(name f-r2)
	(comment "f-reg2")
	(attrs)
	(word-offset 0)
	(word-length 8)
	(start 0)
	(length 8)
	(mode UINT)
)

(define-ifield
	(name f-imm)
	(comment "f-imm")
	(attrs)
	(word-offset 0)
	(word-length 32)
	(start 0)
	(length 32)
	(mode UINT)
)

(define-ifield
	(name f-aaddr)
	(comment "absolute address")
	(attrs ABS-ADDR)
	(word-offset 0)
	(word-length 32)
	(start 0)
	(length 32)
	(mode UINT)
)

(define-ifield
	(name f-raddr)
	(comment "pc-relative address")
	(attrs PCREL-ADDR)
	(word-offset 0)
	(word-length 32)
	(start 0)
	(length 32)
	(mode UINT)
)


; Instruction operands

(dnop rd "destination register" () h-gpr f-r1)
(dnop rs "source register" () h-gpr f-r2)
(dnop simm "signed immediate" () h-sint f-imm)
(dnop aiaddr "absolute instruction address" (RELAX) h-iaddr f-aaddr)
(dnop riaddr "pc-relative instruction address" (RELAX) h-iaddr f-raddr)

(define-operand
  (name imm)
  (comment "hash signed immediate")
  (attrs)
  (type h-sint)
  (index f-imm)
  (handlers (parse "mp2imm"))
)


; Instruction classes

(define-pmacro (define-arith-insn xname xopcode-reg xopcode-imm)
  "Define an arithmetic instruction pair."
	; register version
	(begin
		(define-insn
			(name xname)
			(comment (.str xname))
			(syntax (.str xname " $rd,$rs"))
			(format (+ (f-op xopcode-reg) rd rs))
			(semantics (set rd (xname rd rs)))
		)
		; immediate version
		(define-insn
			(name (.sym xname "i"))
			(comment (.str xname "i"))
			(syntax (.str xname " $rd,$imm"))
			(format (+ (f-op xopcode-imm) rd imm))
			(semantics (set rd (xname rd imm)))
		)
	)
)

(define-pmacro (define-jc-insn xcond xopcode)
  "Define an conditional jump instruction."
	; register version
	(define-insn
		(name (.sym jc "_" xcond))
		(comment (.str jc "_" xcond))
		(syntax (.str jc " " xcond ",$rd,$rs,$imm"))
		(format (+ (f-op xopcode) rd rs imm))
		(semantics (if (xcond rd rs) (set pc imm)))
	)
)

; todo: fix all opcode values.
; Instructions

(define-insn
	(name calli)
	(comment "call immediate")
	(syntax "call &${aiaddr}")
	(format (+ (f-op 61) aiaddr))
	(semantics (sequence ()
		; save return address
		(set (reg rt) (add (reg pc) 4))
		; jump
		(set pc aiaddr)
		))
)

(define-insn
	(name callr)
	(comment "call reg")
	(syntax "call $rd")
	(format (+ (f-op 62) rd))
	(semantics (sequence ()
		; save return address
		(set (reg rt) (add (reg pc) 4))
		; jump
		(set pc rd)
		))
)

(define-jc-insn eq 8)
(define-jc-insn ne 9)
(define-jc-insn ge 10)
(define-jc-insn gt 11)
(define-jc-insn le 12)
(define-jc-insn lt 13)
(define-jc-insn ltu 14)
(define-jc-insn geu 15)
(define-jc-insn gtu 16)
(define-jc-insn leu 17)

(define-arith-insn div 38 39)
(define-arith-insn mul 40 41)
(define-arith-insn add 42 43)
(define-arith-insn sub 44 45)
(define-arith-insn and 46 47)
(define-arith-insn or 48 49)
(define-arith-insn xor 50 51)
(define-arith-insn sll 52 53)
(define-arith-insn sra 54 55)
(define-arith-insn srl 56 57)

(define-insn
	(name not)
	(comment "not")
	(attrs)
	(syntax "not $rd,$rs")
	(format (+ (f-op 58) rd rs))
	(semantics (set rd (not rs)))
)

(define-insn
	(name neg)
	(comment "neg")
	(attrs)
	(syntax "neg $rd,$rs")
	(format (+ (f-op 59) rd rs))
	(semantics (set rd (neg rs)))
)

(define-insn
	(name push)
	(comment "push")
	(syntax "push $rd,$rs")
	(format (+ (f-op 1) rd rs))
	; todo: fixme
	(semantics (set rd (add rd rs)))
)

(define-insn
	(name pop)
	(comment "pop")
	(syntax "pop $rd,$rs")
	(format (+ (f-op 0) rd rs))
	; todo: fixme
	(semantics (set rd (add rd rs)))
)

(define-insn
	(name ret)
	(comment "ret")
	(syntax "ret")
	(format (+ (f-op 60)))
	(semantics (set pc (reg rt)))
)

(define-insn
	(name ldw)
	(comment "ldw")
	(attrs)
	(syntax "ld $rd,[$rs,$simm]")
	(format (+ (f-op 2) rd rs simm))
	(semantics (set rd (mem SI (add rs simm))))
)

(define-insn
	(name ldr)
	(comment "ldr")
	(attrs)
	(syntax "ld $rd,$rs")
	(format (+ (f-op 3) rd rs))
	(semantics (set rd rs))
)

(define-insn
	(name stw)
	(comment "stw")
	(attrs)
	(syntax "ld [$rd,$simm],$rs")
	(format (+ (f-op 4) rd rs simm))
	(semantics (set (mem SI (add rd simm)) rs))
)

(define-normal-macro-insn
	stw0 "stw0" ()
	"ld [$rd],$rs"
	(emit stw rd rs (simm 0))
)

(define-insn
	(name ldi)
	(comment "ldi")
	(attrs)
	(syntax "ld $rd,$imm")
	(format (+ (f-op 5) rd imm))
	(semantics (set rd imm))
)

(define-insn
	(name jpi)
	(comment "jpi")
	(attrs)
	(syntax "jp $imm")
	(format (+ (f-op 6) imm))
	(semantics (set pc imm))
)

(define-insn
	(name jpr)
	(comment "jpr")
	(attrs)
	(syntax "jp $rd")
	(format (+ (f-op 7) rd))
	(semantics (set pc rd))
)
